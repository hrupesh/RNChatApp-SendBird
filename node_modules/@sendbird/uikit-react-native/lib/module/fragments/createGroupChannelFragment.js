import React, { useMemo } from 'react';
import { useGroupChannelMessages } from '@sendbird/uikit-chat-hooks';
import { NOOP, PASS, messageComparator, useFreshCallback } from '@sendbird/uikit-utils';
import MessageRenderer from '../components/MessageRenderer';
import NewMessagesButton from '../components/NewMessagesButton';
import ScrollToBottomButton from '../components/ScrollToBottomButton';
import StatusComposition from '../components/StatusComposition';
import createGroupChannelModule from '../domain/groupChannel/module/createGroupChannelModule';
import { useSendbirdChat } from '../hooks/useContext';

const createGroupChannelFragment = initModule => {
  const GroupChannelModule = createGroupChannelModule(initModule);
  return _ref => {
    let {
      renderNewMessagesButton = props => /*#__PURE__*/React.createElement(NewMessagesButton, props),
      renderScrollToBottomButton = props => /*#__PURE__*/React.createElement(ScrollToBottomButton, props),
      renderMessage,
      enableMessageGrouping = true,
      enableTypingIndicator = true,
      onPressHeaderLeft = NOOP,
      onPressHeaderRight = NOOP,
      onPressImageMessage,
      onPressMediaMessage = NOOP,
      onChannelDeleted = NOOP,
      onBeforeSendFileMessage = PASS,
      onBeforeSendUserMessage = PASS,
      channel,
      keyboardAvoidOffset,
      queryCreator,
      collectionCreator,
      sortComparator = messageComparator,
      flatListProps
    } = _ref;
    const {
      sdk,
      currentUser
    } = useSendbirdChat();
    const {
      messages,
      nextMessages,
      newMessagesFromMembers,
      next,
      prev,
      sendFileMessage,
      sendUserMessage,
      updateFileMessage,
      updateUserMessage,
      resendMessage,
      deleteMessage,
      loading
    } = useGroupChannelMessages(sdk, channel, currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId, {
      collectionCreator,
      queryCreator,
      sortComparator,
      onChannelDeleted,
      enableCollectionWithoutLocalCache: !queryCreator
    });

    const _renderMessage = useFreshCallback(props => {
      if (renderMessage) return renderMessage(props);
      return /*#__PURE__*/React.createElement(MessageRenderer, props);
    });

    const memoizedFlatListProps = useMemo(() => ({
      ListEmptyComponent: /*#__PURE__*/React.createElement(GroupChannelModule.StatusEmpty, null),
      contentContainerStyle: {
        flexGrow: 1
      },
      ...flatListProps
    }), [loading, flatListProps]);
    const onSendFileMessage = useFreshCallback(async file => {
      const processedParams = await onBeforeSendFileMessage({
        file
      });
      await sendFileMessage(processedParams);
    });
    const onSendUserMessage = useFreshCallback(async (text, mention) => {
      const processedParams = await onBeforeSendUserMessage({
        message: text,
        mentionedUserIds: mention === null || mention === void 0 ? void 0 : mention.userIds,
        mentionedMessageTemplate: mention === null || mention === void 0 ? void 0 : mention.messageTemplate,
        mentionType: mention === null || mention === void 0 ? void 0 : mention.type
      });
      await sendUserMessage(processedParams);
    });
    const onUpdateFileMessage = useFreshCallback(async (editedFile, message) => {
      const processedParams = await onBeforeSendFileMessage({
        file: editedFile
      });
      await updateFileMessage(message.messageId, processedParams);
    });
    const onUpdateUserMessage = useFreshCallback(async (editedText, message, mention) => {
      const processedParams = await onBeforeSendUserMessage({
        message: editedText,
        mentionedUserIds: mention === null || mention === void 0 ? void 0 : mention.userIds,
        mentionedMessageTemplate: mention === null || mention === void 0 ? void 0 : mention.messageTemplate,
        mentionType: mention === null || mention === void 0 ? void 0 : mention.type
      });
      await updateUserMessage(message.messageId, processedParams);
    });
    return /*#__PURE__*/React.createElement(GroupChannelModule.Provider, {
      channel: channel,
      enableTypingIndicator: enableTypingIndicator,
      keyboardAvoidOffset: keyboardAvoidOffset
    }, /*#__PURE__*/React.createElement(GroupChannelModule.Header, {
      onPressHeaderLeft: onPressHeaderLeft,
      onPressHeaderRight: onPressHeaderRight
    }), /*#__PURE__*/React.createElement(StatusComposition, {
      loading: loading,
      LoadingComponent: /*#__PURE__*/React.createElement(GroupChannelModule.StatusLoading, null)
    }, /*#__PURE__*/React.createElement(GroupChannelModule.MessageList, {
      channel: channel,
      enableMessageGrouping: enableMessageGrouping,
      currentUserId: currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId,
      renderMessage: _renderMessage,
      messages: messages,
      nextMessages: nextMessages,
      newMessagesFromMembers: newMessagesFromMembers,
      onTopReached: prev,
      onBottomReached: next,
      renderNewMessagesButton: renderNewMessagesButton,
      renderScrollToBottomButton: renderScrollToBottomButton,
      onResendFailedMessage: resendMessage,
      onDeleteMessage: deleteMessage,
      onPressImageMessage: onPressImageMessage,
      onPressMediaMessage: onPressMediaMessage,
      flatListProps: memoizedFlatListProps
    }), /*#__PURE__*/React.createElement(GroupChannelModule.Input, {
      SuggestedMentionList: GroupChannelModule.SuggestedMentionList,
      shouldRenderInput: shouldRenderInput(channel),
      onSendFileMessage: onSendFileMessage,
      onSendUserMessage: onSendUserMessage,
      onUpdateFileMessage: onUpdateFileMessage,
      onUpdateUserMessage: onUpdateUserMessage
    })));
  };
};

function shouldRenderInput(channel) {
  if (channel.isBroadcast) {
    return channel.myRole === 'operator';
  }

  return true;
}

export default createGroupChannelFragment;
//# sourceMappingURL=createGroupChannelFragment.js.map