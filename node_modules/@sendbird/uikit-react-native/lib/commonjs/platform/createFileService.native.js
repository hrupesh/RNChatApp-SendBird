"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactNative = require("react-native");

var _uikitUtils = require("@sendbird/uikit-utils");

var _SBUError = _interopRequireDefault(require("../libs/SBUError"));

var _fileTypeGuard = _interopRequireDefault(require("../utils/fileTypeGuard"));

var _nativePermissionGranted = _interopRequireDefault(require("../utils/nativePermissionGranted"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getAndroidStoragePermissionsByAPILevel(permissionModule) {
  if (_reactNative.Platform.OS !== 'android') return [];

  if (_reactNative.Platform.Version > 32) {
    return [permissionModule.PERMISSIONS.ANDROID.READ_MEDIA_AUDIO, permissionModule.PERMISSIONS.ANDROID.READ_MEDIA_IMAGES, permissionModule.PERMISSIONS.ANDROID.READ_MEDIA_VIDEO];
  }

  if (_reactNative.Platform.Version > 28) {
    return [permissionModule.PERMISSIONS.ANDROID.READ_EXTERNAL_STORAGE];
  }

  return [permissionModule.PERMISSIONS.ANDROID.WRITE_EXTERNAL_STORAGE, permissionModule.PERMISSIONS.ANDROID.READ_EXTERNAL_STORAGE];
}

const createNativeFileService = _ref => {
  let {
    imagePickerModule,
    documentPickerModule,
    permissionModule,
    mediaLibraryModule,
    fsModule
  } = _ref;

  const cameraPermissions = _reactNative.Platform.select({
    ios: [permissionModule.PERMISSIONS.IOS.CAMERA, permissionModule.PERMISSIONS.IOS.MICROPHONE],
    android: [permissionModule.PERMISSIONS.ANDROID.CAMERA],
    default: []
  });

  const mediaLibraryPermissions = _reactNative.Platform.select({
    ios: [permissionModule.PERMISSIONS.IOS.MEDIA_LIBRARY, permissionModule.PERMISSIONS.IOS.PHOTO_LIBRARY],
    android: getAndroidStoragePermissionsByAPILevel(permissionModule),
    default: []
  });

  class NativeFileService {
    async hasCameraPermission() {
      const status = await permissionModule.checkMultiple(cameraPermissions);
      return (0, _nativePermissionGranted.default)(status);
    }

    async requestCameraPermission() {
      const status = await permissionModule.requestMultiple(cameraPermissions);
      return (0, _nativePermissionGranted.default)(status);
    }

    async hasMediaLibraryPermission() {
      const status = await permissionModule.checkMultiple(mediaLibraryPermissions);
      return (0, _nativePermissionGranted.default)(status);
    }

    async requestMediaLibraryPermission() {
      const status = await permissionModule.requestMultiple(mediaLibraryPermissions);
      return (0, _nativePermissionGranted.default)(status);
    }

    async openCamera(options) {
      var _response$assets;

      const hasPermission = await this.hasCameraPermission();

      if (!hasPermission) {
        const granted = await this.requestCameraPermission();

        if (!granted) {
          var _options$onOpenFailur;

          options === null || options === void 0 ? void 0 : (_options$onOpenFailur = options.onOpenFailure) === null || _options$onOpenFailur === void 0 ? void 0 : _options$onOpenFailur.call(options, _SBUError.default.PERMISSIONS_DENIED);
          return null;
        }
      }

      const response = await imagePickerModule.launchCamera({
        presentationStyle: 'fullScreen',
        cameraType: (options === null || options === void 0 ? void 0 : options.cameraType) ?? 'back',
        mediaType: (() => {
          switch (options === null || options === void 0 ? void 0 : options.mediaType) {
            case 'photo':
              return 'photo';

            case 'video':
              return 'video';

            case 'all':
              return 'mixed';

            default:
              return 'photo';
          }
        })()
      });
      if (response.didCancel) return null;

      if (response.errorCode === 'camera_unavailable') {
        var _options$onOpenFailur2;

        options === null || options === void 0 ? void 0 : (_options$onOpenFailur2 = options.onOpenFailure) === null || _options$onOpenFailur2 === void 0 ? void 0 : _options$onOpenFailur2.call(options, _SBUError.default.DEVICE_UNAVAILABLE, new Error(response.errorMessage));
        return null;
      }

      const {
        fileName: name,
        fileSize: size,
        type,
        uri
      } = ((_response$assets = response.assets) === null || _response$assets === void 0 ? void 0 : _response$assets[0]) ?? {};
      return (0, _fileTypeGuard.default)({
        uri,
        size,
        name,
        type
      });
    }

    async openMediaLibrary(options) {
      /**
       * NOTE: options.selectionLimit {@link https://github.com/react-native-image-picker/react-native-image-picker#options}
       * We do not support 0 (any number of files)
       **/
      const selectionLimit = (options === null || options === void 0 ? void 0 : options.selectionLimit) || 1;
      const hasPermission = await this.hasMediaLibraryPermission();

      if (!hasPermission) {
        const granted = await this.requestMediaLibraryPermission();

        if (!granted) {
          var _options$onOpenFailur3;

          options === null || options === void 0 ? void 0 : (_options$onOpenFailur3 = options.onOpenFailure) === null || _options$onOpenFailur3 === void 0 ? void 0 : _options$onOpenFailur3.call(options, _SBUError.default.PERMISSIONS_DENIED);
          return null;
        }
      }

      const response = await imagePickerModule.launchImageLibrary({
        presentationStyle: 'fullScreen',
        selectionLimit,
        mediaType: (() => {
          switch (options === null || options === void 0 ? void 0 : options.mediaType) {
            case 'photo':
              return 'photo';

            case 'video':
              return 'video';

            case 'all':
              return 'mixed';

            default:
              return 'photo';
          }
        })()
      });
      if (response.didCancel) return null;

      if (response.errorCode === 'camera_unavailable') {
        var _options$onOpenFailur4;

        options === null || options === void 0 ? void 0 : (_options$onOpenFailur4 = options.onOpenFailure) === null || _options$onOpenFailur4 === void 0 ? void 0 : _options$onOpenFailur4.call(options, _SBUError.default.DEVICE_UNAVAILABLE, new Error(response.errorMessage));
        return null;
      }

      return (response.assets || []).slice(0, selectionLimit).map(_ref2 => {
        let {
          fileName: name,
          fileSize: size,
          type,
          uri
        } = _ref2;
        return (0, _fileTypeGuard.default)({
          uri,
          size,
          name,
          type
        });
      });
    }

    async openDocument(options) {
      try {
        const {
          uri,
          size,
          name,
          type
        } = await documentPickerModule.pickSingle();
        return (0, _fileTypeGuard.default)({
          uri,
          size,
          name,
          type
        });
      } catch (e) {
        if (!documentPickerModule.isCancel(e) && documentPickerModule.isInProgress(e)) {
          var _options$onOpenFailur5;

          options === null || options === void 0 ? void 0 : (_options$onOpenFailur5 = options.onOpenFailure) === null || _options$onOpenFailur5 === void 0 ? void 0 : _options$onOpenFailur5.call(options, _SBUError.default.UNKNOWN, e);
        }

        return null;
      }
    }

    async save(options) {
      const hasPermission = await this.hasMediaLibraryPermission();

      if (!hasPermission) {
        const granted = await this.requestMediaLibraryPermission();
        if (!granted) throw new Error('Permission not granted');
      }

      const basePath = _reactNative.Platform.select({
        android: fsModule.Dirs.CacheDir,
        default: fsModule.Dirs.DocumentDir
      });

      let downloadPath = `${basePath}/${options.fileName}`;

      if (!(0, _uikitUtils.getFileExtension)(options.fileName)) {
        const extensionFromUrl = (0, _uikitUtils.getFileExtension)(options.fileUrl);

        if ((0, _uikitUtils.getFileType)(extensionFromUrl).match(/image|video/)) {
          downloadPath += extensionFromUrl;
        }
      }

      await fsModule.FileSystem.fetch(options.fileUrl, {
        path: downloadPath
      });
      const fileType = (0, _uikitUtils.getFileType)((0, _uikitUtils.getFileExtension)(options.fileUrl));

      if (_reactNative.Platform.OS === 'ios' && (fileType === 'image' || fileType === 'video')) {
        const type = {
          'image': 'photo',
          'video': 'video'
        }[fileType];
        await mediaLibraryModule.save(downloadPath, {
          type
        });
      }

      if (_reactNative.Platform.OS === 'android') {
        const dirType = {
          'file': 'downloads',
          'audio': 'audio',
          'image': 'images',
          'video': 'video'
        };
        await fsModule.FileSystem.cpExternal(downloadPath, (0, _uikitUtils.normalizeFileName)(options.fileName, (0, _uikitUtils.getFileExtension)(options.fileUrl)), dirType[fileType]);
      }

      return downloadPath;
    }

  }

  return new NativeFileService();
};

var _default = createNativeFileService;
exports.default = _default;
//# sourceMappingURL=createFileService.native.js.map