import { getFileExtension, getFileType } from './regex';
/**
 * Converts a given string to a hashed string.
 * */

export function hash(str) {
  return String(Math.abs(str.split('').reduce((a, c) => (a << 5) - a + c.charCodeAt(0) | 0, 0)));
}
/**
 * Replace a specific range of text in the string with another text.
 * */

export function replace(str, start, end, text) {
  return str.slice(0, start) + text + str.slice(end);
}
/**
 * Returns the value corresponding to the first true index of a given condition array.
 * */

export function conditionChaining(conditions, values) {
  const idx = conditions.findIndex(state => Boolean(state));
  return idx > -1 ? values[idx] : values[values.length - 1];
}
/**
 * Calculates the downscale size.
 * */

export function getDownscaleSize(origin, resizing) {
  let ratio;
  const maxWidth = resizing.width || origin.width,
        maxHeight = resizing.height || origin.height;

  if (origin.width <= maxWidth && origin.height <= maxHeight) {
    ratio = 1;
  } else if (origin.width > maxWidth && origin.height <= maxHeight) {
    ratio = maxWidth / origin.width;
  } else if (origin.width <= maxWidth && origin.height > maxHeight) {
    ratio = maxHeight / origin.height;
  } else {
    ratio = Math.max(maxWidth / origin.width, maxHeight / origin.height);
  }

  return {
    width: origin.width * ratio,
    height: origin.height * ratio
  };
}
export function isImage(filePath, mimeType) {
  const type = getFileType(mimeType || getFileExtension(filePath));
  return type === 'image';
}
export function shouldCompressImage(filePath) {
  let compressionEnabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const extension = getFileExtension(filePath);
  return Boolean(extension.match(/jpg|jpeg|png/i) && compressionEnabled);
}
//# sourceMappingURL=index.js.map