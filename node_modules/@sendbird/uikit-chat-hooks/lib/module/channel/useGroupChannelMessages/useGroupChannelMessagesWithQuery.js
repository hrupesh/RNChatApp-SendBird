import { useCallback, useRef } from 'react';
import { Logger, confirmAndMarkAsRead, isDifferentChannel, useAsyncEffect, useForceUpdate } from '@sendbird/uikit-utils';
import { useChannelHandler } from '../../handler/useChannelHandler';
import { useGroupChannelMessagesReducer } from './reducer';

const createMessageQuery = (channel, creator) => {
  if (creator) return creator();
  return channel.createPreviousMessageListQuery({
    limit: 100,
    reverse: true
  });
};

const HOOK_NAME = 'useGroupChannelMessagesWithQuery';
export const useGroupChannelMessagesWithQuery = (sdk, channel, userId, options) => {
  const queryRef = useRef();
  const forceUpdate = useForceUpdate();
  const {
    loading,
    refreshing,
    messages,
    nextMessages,
    newMessagesFromMembers,
    updateMessages,
    updateNextMessages,
    deleteNextMessages,
    deleteMessages,
    updateLoading,
    updateRefreshing
  } = useGroupChannelMessagesReducer(userId, options === null || options === void 0 ? void 0 : options.sortComparator);

  const channelMarkAsRead = async () => {
    try {
      await confirmAndMarkAsRead([channel]);
    } catch (e) {
      Logger.warn(`[${HOOK_NAME}/channelMarkAsRead]`, e);
    }
  };

  const init = useCallback(async uid => {
    if (uid) {
      var _queryRef$current;

      queryRef.current = createMessageQuery(channel, options === null || options === void 0 ? void 0 : options.queryCreator);
      channelMarkAsRead().catch();

      if ((_queryRef$current = queryRef.current) !== null && _queryRef$current !== void 0 && _queryRef$current.hasNext) {
        var _queryRef$current2;

        const list = await ((_queryRef$current2 = queryRef.current) === null || _queryRef$current2 === void 0 ? void 0 : _queryRef$current2.load());
        updateMessages(list, true, sdk.currentUser.userId);
      }

      updateNextMessages([], true, sdk.currentUser.userId);
    }
  }, [sdk, channel.url, options === null || options === void 0 ? void 0 : options.queryCreator]);

  const channelUpdater = channel => {
    if (channel.isGroupChannel() && !isDifferentChannel(channel, channel)) {
      forceUpdate();
    }
  };

  useChannelHandler(sdk, HOOK_NAME, {
    // Messages
    onMessageReceived(eventChannel, message) {
      if (isDifferentChannel(channel, eventChannel)) return;
      channelMarkAsRead();
      updateNextMessages([message], false, sdk.currentUser.userId);
    },

    onMessageUpdated(eventChannel, message) {
      if (isDifferentChannel(channel, eventChannel)) return;
      updateMessages([message], false, sdk.currentUser.userId);
    },

    onMessageDeleted(eventChannel, messageId) {
      if (isDifferentChannel(channel, eventChannel)) return;
      deleteMessages([messageId], []);
      deleteNextMessages([messageId], []);
    },

    // Channels
    onChannelChanged: channelUpdater,
    onChannelFrozen: channelUpdater,
    onChannelUnfrozen: channelUpdater,
    onChannelHidden: channelUpdater,

    onChannelMemberCountChanged(channels) {
      const foundChannel = channels.find(c => !isDifferentChannel(c, channel));
      if (foundChannel) channelUpdater(foundChannel);
    },

    onChannelDeleted(channelUrl) {
      var _options$onChannelDel;

      if (channel.url === channelUrl) options === null || options === void 0 ? void 0 : (_options$onChannelDel = options.onChannelDeleted) === null || _options$onChannelDel === void 0 ? void 0 : _options$onChannelDel.call(options);
    },

    // Users
    onOperatorUpdated: channelUpdater,
    onUserLeft: channelUpdater,
    // onUserEntered: channelUpdater,
    // onUserExited: channelUpdater,
    onUserJoined: channelUpdater,
    onUserUnbanned: channelUpdater,
    onUserMuted: channelUpdater,
    onUserUnmuted: channelUpdater,

    onUserBanned(eventChannel, bannedUser) {
      if (isDifferentChannel(channel, eventChannel)) return;

      if (bannedUser.userId === sdk.currentUser.userId) {
        var _options$onChannelDel2;

        options === null || options === void 0 ? void 0 : (_options$onChannelDel2 = options.onChannelDeleted) === null || _options$onChannelDel2 === void 0 ? void 0 : _options$onChannelDel2.call(options);
      } else {
        channelUpdater(eventChannel);
      }
    }

  });
  useAsyncEffect(async () => {
    updateLoading(true);
    await init(userId);
    updateLoading(false);
  }, [init, userId]);
  const refresh = useCallback(async () => {
    updateRefreshing(true);
    await init(userId);
    updateRefreshing(false);
  }, [init, userId]);
  const prev = useCallback(async () => {
    var _queryRef$current3;

    if (queryRef.current && (_queryRef$current3 = queryRef.current) !== null && _queryRef$current3 !== void 0 && _queryRef$current3.hasNext) {
      var _queryRef$current4;

      const list = await ((_queryRef$current4 = queryRef.current) === null || _queryRef$current4 === void 0 ? void 0 : _queryRef$current4.load());
      updateMessages(list, false, sdk.currentUser.userId);
    }
  }, []);
  const next = useCallback(async () => {
    if (nextMessages.length > 0) {
      updateMessages(nextMessages, false, sdk.currentUser.userId);
      updateNextMessages([], true, sdk.currentUser.userId);
    }
  }, [nextMessages.length]);
  const sendUserMessage = useCallback((params, onPending) => {
    return new Promise((resolve, reject) => {
      channel.sendUserMessage(params).onPending(pendingMessage => {
        if (pendingMessage.isUserMessage()) {
          updateNextMessages([pendingMessage], false, sdk.currentUser.userId);
          onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
        }
      }).onSucceeded(sentMessage => {
        if (sentMessage.isUserMessage()) {
          updateNextMessages([sentMessage], false, sdk.currentUser.userId);
          resolve(sentMessage);
        }
      }).onFailed(err => {
        reject(err);
      });
    });
  }, [channel]);
  const sendFileMessage = useCallback((params, onPending) => {
    return new Promise((resolve, reject) => {
      channel.sendFileMessage(params).onPending(pendingMessage => {
        if (pendingMessage.isFileMessage()) {
          updateNextMessages([pendingMessage], false, sdk.currentUser.userId);
          onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
        }
      }).onSucceeded(sentMessage => {
        if (sentMessage.isFileMessage()) {
          updateNextMessages([sentMessage], false, sdk.currentUser.userId);
          resolve(sentMessage);
        }
      }).onFailed(err => {
        reject(err);
      });
    });
  }, [channel]);
  const updateUserMessage = useCallback(async (messageId, params) => {
    const updatedMessage = await channel.updateUserMessage(messageId, params);
    updateMessages([updatedMessage], false, sdk.currentUser.userId);
    return updatedMessage;
  }, [channel]);
  const updateFileMessage = useCallback(async (messageId, params) => {
    const updatedMessage = await channel.updateFileMessage(messageId, params);
    updateMessages([updatedMessage], false, sdk.currentUser.userId);
    return updatedMessage;
  }, [channel]);
  const resendMessage = useCallback(async failedMessage => {
    const message = await (() => {
      if (failedMessage.isUserMessage()) return channel.resendUserMessage(failedMessage);
      if (failedMessage.isFileMessage()) return channel.resendFileMessage(failedMessage);
      return null;
    })();
    if (message) updateNextMessages([message], false, sdk.currentUser.userId);
  }, [channel]);
  const deleteMessage = useCallback(async message => {
    if (message.sendingStatus === 'succeeded') {
      if (message.isUserMessage()) await channel.deleteMessage(message);
      if (message.isFileMessage()) await channel.deleteMessage(message);
    } else {
      deleteMessages([message.messageId], [message.reqId]);
    }
  }, [channel]);
  return {
    loading,
    refreshing,
    refresh,
    messages,
    nextMessages,
    newMessagesFromMembers,
    next,
    prev,
    sendUserMessage,
    sendFileMessage,
    updateUserMessage,
    updateFileMessage,
    resendMessage,
    deleteMessage
  };
};
//# sourceMappingURL=useGroupChannelMessagesWithQuery.js.map