import { useCallback, useEffect, useRef } from 'react';
import { MessageCollectionInitPolicy, MessageEventSource, MessageFilter } from '@sendbird/chat/groupChannel';
import { Logger, confirmAndMarkAsRead, isDifferentChannel, useForceUpdate, useFreshCallback } from '@sendbird/uikit-utils';
import { useChannelHandler } from '../../handler/useChannelHandler';
import { useGroupChannelMessagesReducer } from './reducer';

const createMessageCollection = (channel, creator) => {
  if (creator) return creator();
  const filter = new MessageFilter();
  return channel.createMessageCollection({
    filter,
    limit: 100
  });
};

const HOOK_NAME = 'useGroupChannelMessagesWithCollection';
export const useGroupChannelMessagesWithCollection = (sdk, channel, userId, options) => {
  const forceUpdate = useForceUpdate();
  const collectionRef = useRef();
  const {
    loading,
    refreshing,
    messages,
    nextMessages,
    newMessagesFromMembers,
    updateMessages,
    updateNextMessages,
    deleteNextMessages,
    deleteMessages,
    updateLoading,
    updateRefreshing
  } = useGroupChannelMessagesReducer(userId, options === null || options === void 0 ? void 0 : options.sortComparator);

  const channelMarkAsRead = async source => {
    try {
      switch (source) {
        case MessageEventSource.EVENT_MESSAGE_RECEIVED:
        case MessageEventSource.EVENT_MESSAGE_SENT_SUCCESS:
        case MessageEventSource.SYNC_MESSAGE_FILL:
        case undefined:
          await confirmAndMarkAsRead([channel]);
          break;
      }
    } catch (e) {
      Logger.warn(`[${HOOK_NAME}/channelMarkAsRead]`, e);
    }
  };

  const init = useCallback(async (uid, callback) => {
    var _collectionRef$curren;

    if (collectionRef.current) (_collectionRef$curren = collectionRef.current) === null || _collectionRef$curren === void 0 ? void 0 : _collectionRef$curren.dispose();

    if (uid) {
      var _collectionRef$curren2;

      collectionRef.current = createMessageCollection(channel, options === null || options === void 0 ? void 0 : options.collectionCreator);
      updateNextMessages([], true, sdk.currentUser.userId);
      channelMarkAsRead();
      (_collectionRef$curren2 = collectionRef.current) === null || _collectionRef$curren2 === void 0 ? void 0 : _collectionRef$curren2.setMessageCollectionHandler({
        onMessagesAdded: (_, __, messages) => {
          channelMarkAsRead(_.source);
          updateNextMessages(messages, false, sdk.currentUser.userId);
        },
        onMessagesUpdated: (_, __, messages) => {
          channelMarkAsRead(_.source); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.

          if (_.source === MessageEventSource.EVENT_MESSAGE_RECEIVED) {
            const nextMessageIds = nextMessages.map(it => it.messageId);
            const nonAddedMessagesFromReceivedEvent = messages.filter(it => nextMessageIds.indexOf(it.messageId) === -1);
            updateNextMessages(nonAddedMessagesFromReceivedEvent, false, sdk.currentUser.userId);
          } // NOTE: v4 MESSAGE_RECEIVED is called twice from onMessagesAdded and onMessagesUpdated when receiving new message.
          //  This is not intended behavior but not bugs.


          if (_.source !== MessageEventSource.EVENT_MESSAGE_RECEIVED) {
            updateMessages(messages, false, sdk.currentUser.userId);
          }
        },
        onMessagesDeleted: (_, __, messageIds) => {
          deleteMessages(messageIds, []);
          deleteNextMessages(messageIds, []);
        },
        onChannelDeleted: () => {
          var _options$onChannelDel;

          options === null || options === void 0 ? void 0 : (_options$onChannelDel = options.onChannelDeleted) === null || _options$onChannelDel === void 0 ? void 0 : _options$onChannelDel.call(options);
        },
        onChannelUpdated: (_, eventChannel) => {
          if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channel)) {
            forceUpdate();
          }
        },
        onHugeGapDetected: () => {
          init(uid);
        }
      });
      collectionRef.current.initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API).onCacheResult((err, messages) => {
        if (err) sdk.isCacheEnabled && Logger.error(`[${HOOK_NAME}/onCacheResult]`, err);else {
          var _collectionRef$curren3, _collectionRef$curren4;

          Logger.debug(`[${HOOK_NAME}/onCacheResult]`, 'message length:', messages.length);
          updateMessages(messages, true, sdk.currentUser.userId);
          updateMessages(((_collectionRef$curren3 = collectionRef.current) === null || _collectionRef$curren3 === void 0 ? void 0 : _collectionRef$curren3.pendingMessages) ?? [], false, sdk.currentUser.userId);
          updateMessages(((_collectionRef$curren4 = collectionRef.current) === null || _collectionRef$curren4 === void 0 ? void 0 : _collectionRef$curren4.failedMessages) ?? [], false, sdk.currentUser.userId);
        }
        callback === null || callback === void 0 ? void 0 : callback();
      }).onApiResult((err, messages) => {
        if (err) Logger.warn(`[${HOOK_NAME}/onApiResult]`, err);else {
          Logger.debug(`[${HOOK_NAME}/onApiResult]`, 'message length:', messages.length);
          updateMessages(messages, true, sdk.currentUser.userId);

          if (sdk.isCacheEnabled) {
            var _collectionRef$curren5, _collectionRef$curren6;

            updateMessages(((_collectionRef$curren5 = collectionRef.current) === null || _collectionRef$curren5 === void 0 ? void 0 : _collectionRef$curren5.pendingMessages) ?? [], false, sdk.currentUser.userId);
            updateMessages(((_collectionRef$curren6 = collectionRef.current) === null || _collectionRef$curren6 === void 0 ? void 0 : _collectionRef$curren6.failedMessages) ?? [], false, sdk.currentUser.userId);
          }
        }
        callback === null || callback === void 0 ? void 0 : callback();
      });
    }
  }, [sdk, channel.url, options === null || options === void 0 ? void 0 : options.collectionCreator]);
  useChannelHandler(sdk, HOOK_NAME, {
    onUserBanned(channel, bannedUser) {
      if (channel.isGroupChannel() && !isDifferentChannel(channel, channel)) {
        if (bannedUser.userId === sdk.currentUser.userId) {
          var _options$onChannelDel2;

          options === null || options === void 0 ? void 0 : (_options$onChannelDel2 = options.onChannelDeleted) === null || _options$onChannelDel2 === void 0 ? void 0 : _options$onChannelDel2.call(options);
        } else {
          forceUpdate();
        }
      }
    }

  });
  useEffect(() => {
    // NOTE: Cache read is heavy task, and it prevents smooth ui transition
    setTimeout(async () => {
      updateLoading(true);
      init(userId, () => updateLoading(false));
    }, 0);
  }, [init, userId]);
  useEffect(() => {
    return () => {
      var _collectionRef$curren7;

      if (collectionRef.current) (_collectionRef$curren7 = collectionRef.current) === null || _collectionRef$curren7 === void 0 ? void 0 : _collectionRef$curren7.dispose();
    };
  }, []);
  const refresh = useFreshCallback(async () => {
    updateRefreshing(true);
    init(userId, () => updateRefreshing(false));
  });
  const prev = useFreshCallback(async () => {
    var _collectionRef$curren8;

    if (collectionRef.current && (_collectionRef$curren8 = collectionRef.current) !== null && _collectionRef$curren8 !== void 0 && _collectionRef$curren8.hasPrevious) {
      try {
        var _collectionRef$curren9;

        const list = await ((_collectionRef$curren9 = collectionRef.current) === null || _collectionRef$curren9 === void 0 ? void 0 : _collectionRef$curren9.loadPrevious());
        updateMessages(list, false, sdk.currentUser.userId);
      } catch {}
    }
  });
  const next = useFreshCallback(async () => {
    var _collectionRef$curren10;

    const messageCandidates = [];

    if (collectionRef.current && (_collectionRef$curren10 = collectionRef.current) !== null && _collectionRef$curren10 !== void 0 && _collectionRef$curren10.hasNext) {
      try {
        var _collectionRef$curren11;

        const fetchedList = await ((_collectionRef$curren11 = collectionRef.current) === null || _collectionRef$curren11 === void 0 ? void 0 : _collectionRef$curren11.loadNext());
        messageCandidates.push(...fetchedList);
      } catch {}
    }

    if (nextMessages.length > 0) {
      messageCandidates.push(...nextMessages);
    }

    if (messageCandidates.length > 0) {
      updateMessages(messageCandidates, false, sdk.currentUser.userId);
      updateNextMessages([], true, sdk.currentUser.userId);
    }
  });
  const sendUserMessage = useFreshCallback((params, onPending) => {
    return new Promise((resolve, reject) => {
      channel.sendUserMessage(params).onPending(pendingMessage => {
        if (pendingMessage.isUserMessage()) {
          onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
          updateMessages([pendingMessage], false, sdk.currentUser.userId);
        }
      }).onSucceeded(sentMessage => {
        if (sentMessage.isUserMessage()) {
          updateMessages([sentMessage], false, sdk.currentUser.userId);
          resolve(sentMessage);
        }
      }).onFailed((err, _failedMessage) => {
        // updateMessages([failedMessage], false, sdk.currentUser.userId);
        reject(err);
      });
    });
  });
  const sendFileMessage = useFreshCallback((params, onPending) => {
    return new Promise((resolve, reject) => {
      channel.sendFileMessage(params).onPending(pendingMessage => {
        if (pendingMessage.isFileMessage()) {
          updateMessages([pendingMessage], false, sdk.currentUser.userId);
          onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
        }
      }).onSucceeded(sentMessage => {
        if (sentMessage.isFileMessage()) {
          updateMessages([sentMessage], false, sdk.currentUser.userId);
          resolve(sentMessage);
        }
      }).onFailed((err, _failedMessage) => {
        // updateMessages([failedMessage], false, sdk.currentUser.userId);
        reject(err);
      });
    });
  });
  const updateUserMessage = useFreshCallback(async (messageId, params) => {
    const updatedMessage = await channel.updateUserMessage(messageId, params);
    updateMessages([updatedMessage], false, sdk.currentUser.userId);
    return updatedMessage;
  });
  const updateFileMessage = useFreshCallback(async (messageId, params) => {
    const updatedMessage = await channel.updateFileMessage(messageId, params);
    updateMessages([updatedMessage], false, sdk.currentUser.userId);
    return updatedMessage;
  });
  const resendMessage = useFreshCallback(async failedMessage => {
    const resentMessage = await (() => {
      if (failedMessage.isUserMessage()) return channel.resendUserMessage(failedMessage);
      if (failedMessage.isFileMessage()) return channel.resendFileMessage(failedMessage);
      return null;
    })();
    if (resentMessage) updateMessages([resentMessage], false, sdk.currentUser.userId);
  });
  const deleteMessage = useFreshCallback(async message => {
    if (message.sendingStatus === 'succeeded') {
      if (message.isUserMessage()) await channel.deleteMessage(message);
      if (message.isFileMessage()) await channel.deleteMessage(message);
    } else {
      try {
        var _collectionRef$curren12;

        await ((_collectionRef$curren12 = collectionRef.current) === null || _collectionRef$curren12 === void 0 ? void 0 : _collectionRef$curren12.removeFailedMessage(message.reqId));
      } finally {
        deleteMessages([message.messageId], [message.reqId]);
      }
    }
  });
  return {
    loading,
    refreshing,
    refresh,
    messages,
    nextMessages,
    newMessagesFromMembers,
    next,
    prev,
    sendUserMessage,
    sendFileMessage,
    updateUserMessage,
    updateFileMessage,
    resendMessage,
    deleteMessage
  };
};
//# sourceMappingURL=useGroupChannelMessagesWithCollection.js.map